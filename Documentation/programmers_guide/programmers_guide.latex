\documentclass{report}
\usepackage[T1]{fontenc}

%\usepackage{html}
%\bodytext{link="#662a00" vlink="#666655" bgcolor="#ffffff"}

\title{Ecasound Programmer's Guide}
\author{Kai Vehmanen}
\date{18112003}
\begin{document}

\maketitle
\tableofcontents 
\clearpage

% ----------------------------------------------------------------------
% ----------------------------------------------------------------------
\chapter{Preface}

This document describes how Ecasound and the related libraries
work, how to use them, how to extend and add features and other 
similar issues. Before reading this document, you should first take a 
look at other available documentation (especially 
\texttt{Ecasound Users's Guide}).

If not otherwise specified, all documentation refers to the latest
Ecasound version.

% ----------------------------------------------------------------------
% ----------------------------------------------------------------------
\chapter{Document history}

\begin{itemize}
\item 18.11.2003 - Typo fixes. Updated documentation to reflect the new
                   naming convention (ecasound refers to the binary,
		   Ecasound refers to the whole package).
\item 07.11.2002 - Added documentation for NetECI.
\item 25.10.2002 - Added ``Checklist for Audio Object Implementations''.
\item 17.10.2002 - Added a warning against direct use of libecasound
                   and libkvutils. Using ECI is from now on the 
		   preferred way of using ecasound as a development
		   platform. Rewrote the ``Versioning'' section.
\item 02.10.2002 - Added the ``Protocols and Interfaces'' chapter.
\item 29.04.2002 - Added chapter about ``Unit Tests'' \cite{unit_tests}.
\item 28.04.2002 - Revised namespace policy (see chapter
                   \ref{cpp_std_namespace}), replaced references to
		   the obsolete ECA\_DEBUG with a description
		   of the new ECA\_LOGGER subsystem.
\item 27.02.2002 - Rewrote the ``Control flows'' chapter according 
                   to the structural changes made in 2.1dev8. Added
		   a ``References'' section.
\item 31.01.2002 - Reorganization of document structure. New chapter 
                   about ``Library organization''.
\item 19.12.2001 - Added chapter \ref{include_hierarchies} about include hierarchies.
\item 28.10.2001 - Lots of changes to the ``Object maps'' chapter.
\item 21.10.2001 - Added this history section.
\end{itemize}

% ----------------------------------------------------------------------
% ----------------------------------------------------------------------
\chapter{General programming guidelines}

% ----------------------------------------------------------------------
\section{Design and programming}

\subsection{Open and generic design}

Over the years ecasound's core design has been revised many times.
After rewriting some code sections hundreds of times, you start
to appreciate genericity. :)

\subsection{Object-orientation}

Ecasound is written in C++ (as specified in 1997 ANSI/ISO C++ standard). 
When designing classes and routines, I often use Eiffel language as 
a reference. At same time overuse of object-orientation is another
thing to avoid. Object-orientation is a very effective design method, 
but not the only one. Sometimes other approaches work better.

\subsection{Data hiding} 

This design principle deserves to be mentioned separately. Whenever 
possible, the actual data representation and implementation 
should always be hidden. This allows you to make local implementation 
changes without affecting other parts of the code base. It cannot
be emphasized enough how important this goal is for large software 
projects like Ecasound.

\subsection{Design by contract} 

Design by contract means that when you write a new routine,
in addition to the actual code, you also describe routine's 
behaviour as accurately as possible by defining a set 
of preconditions and postconditions. These conditions are
usually defined using boolean assertations.

Routine must specify all requirements and assumptions. 
If the caller violates this specification, routine is not 
responsible for the error. This means that routine mustn't
check argument validity. This must be done by the caller.

Routine should also specify, what conditions are true when
returning to the caller. By doing this, routine ensures that
it works correctly and calling routine knows what has been
done.

Ideally, these conditions \emph{prove} that the routine works 
correctly. Unfortunately writing good conditions is not 
always easy. Still, the benefits of this approach should be 
clear. When you call a well-defined routine, a) you know what 
parameter values it accepts, b) you know what it does and c) if 
errors occur, it's easier to pinpoint the faulty routine. In 
practice this is done by using comments and pre/postconditions. 

As C++ doesn't directly support pre/postconditions, I've simulated 
them using the DEFINITION\_BY\_CONTRACT and DBC tools provided by 
libkvutils.

\subsection{Routine side effects}

I try to make a clear distinction between routines that 
have side-effects (=methods, processors, modifiers; routines that
change object's state) and const routines (=functions, observers).

To make monitoring side effects easier, all Ecasound classes 
should be const-correct. A object is const-correct if a function
taking only a single argument that is a const reference to that object
is not able, without explicit casting, to obtain a non-const
reference to that same object (or a portion thereof) from within
the function body. \cite{Lakos96}

\subsection{Sanity checks}

Sanity checks are done only to prevent crashes. All effects
and operators happily accept "insane" parameters. For instance 
you can give -100.0\% to the amplifier effect. This of course 
results in inverted sample data. I think this a reasonable 
approach. After all, Ecasound is supposed to be a tool for creative
work and experimenting. It's not meant for e-commerce. ;)

\subsection{Error handling}

Two specific things worth mentioning: First, the standard UNIX-style 
error handling, where functions performing actions return an integer 
value, is \emph{not} used in Ecasound. As described in the above section 
\emph{Routine side effects}, all routines are either modifiers or
observers, not both. So when using Ecasound APIs, you first perform an
action (modifying function), and then afterwards check what happened
(using an observer function).

\subsection{Exceptions}

C++ exceptions are used in Ecasound. Exception based error
handling has its problems, but in some cases it is clearly the best
option. Exceptions are most useful in situations where 
controlled error recovery is very difficult, and in situations
where errors occurs only very rarely. This allows callers to 
avoid constantly checking returns values for functions that 
in normal use never fail. Another special case is handling critical
errors that occur in class contructors.

Using exceptions for anything other than pure error handling 
is to be avoided at all cost. And when exceptions are used,
their use must be specified in function prototypes. This is important,
as clients need to know what exceptions can be thrown. C++ 
unfortunately doesn't require strict exception prototypes, so
this issue requires extra care.

A list of specific cases where exceptions are used follows:

\begin{description}
\item[AUDIO\_IO - open()]
This method is used for initializing external connections (opening
files or devices, loading shared libraries, opening IPC connections). 
It's impossible to know in advance what might happen. In many cases it
is also useful to get more verbose information about the problem 
that caused open() to fail. Throwing an exception is an excellent way
to achieve this.

\item[ECA\_CHAINSETUP - enable()]
\item[ECA\_CHAINSETUP - load\_from\_\texttt{}, save() and save\_to\_\texttt{}]
\item[ECA\_SESSION - constructor]

\end{description}

% ----------------------------------------------------------------------
\section{Coding style}

\subsection{Variable and type naming}

Variable names are all lower case and words are separated with
underscores (int very\_long\_variable\_name\_with\_underscores). Class data
members are marked with \emph{\_rep} postfix. Data members which are
pointers are marked with \emph{\_repp}. Index-style short variable names 
(\emph{n}, \emph{m}, etc.) are only used in local scopes. Enum types 
have capitalized names (\emph{Some\_enum}).

\subsection{Package specific}

\begin{description}
\item[libecasound, ecasound, ecatools, libkvutils]
Class names are all in upper case and words separated with underscores
(class ECA\_CONTROL\_BASE). This a standard style in Eiffel programming.

\item[libqtecasound, qtecasound, ecawave]
Qt-style is used when naming classes (class QELevelMeter), otherwise
same as above.
\end{description}

\subsection{Private classes}

Some classes are divided into public and private parts. This is
done to make it easier to maintain binary-level compatibility 
between library versions, and to get rid of header file 
dependecies. 

Private classes have a \emph{\_impl} postfix in their name. They
are usually stored into separate files which also use the
\emph{\_impl} notation.

For instance the ECA\_ENGINE class (eca-engine.h) has
a private class ECA\_ENGINE\_impl (eca-engine\_impl.h). 
Access to ECA\_ENGINE\_impl is only allowed to ECA\_ENGINE 
member functions. In addition, the private header file 
(eca-engine\_impl.h) is only included from the ECA\_ENGINE 
implementation file (eca-engine.cpp). This allows us to 
add new data members to ECA\_ENGINE\_impl without breaking 
the binary interface.

\subsection{Unit tests}
\label{unit_tests}

Unit tests are used for verifying that modules work as intended. 
A test for component, with a public interface defined in 
``prefix-component.h'', should located in
``prefix-component\_test.h''. The test itself should implement
the ECA\_TEST\_CASE interface. In addition, generic test cases 
should be added to ECA\_TEST\_REPOSITORY - see 
``libecasound/eca-test-repository.cpp''.

% ----------------------------------------------------------------------
\section{Physical level organization}

Ecasound libraries and applications are divided into \emph{distribution 
packages}, \emph{directories} and \emph{file groups}. 

\subsection{Include hierarchies}
\label{include_hierarchies}

Include statements that are not stricly necessary should be dropped!
Not only do they cause unwanted dependencies, they also create more
work for the compiler. Ecasound already takes painfully long to 
compile, so there's no room for sloppy include work. Few distinct
rules follow:

\begin{itemize}
\item In header files, no extra header files should be defined.
      For instance in many cases it's enough to state that 
      object SOME\_TYPE is a class without need for the full 
      implementation; so instead of ``\#include ``sometype.h'', use
      ``class SOME\_TYPE;''.
\item For modules with separate implementation and header files, 
      dependencies to other modules don't need to be 
      stated in both.
\item Direct dependencies to outside modules must always 
      be mentioned directly. It's easy to unknowingly include 
      a required header file via some other header file. This
      should be avoided as it hides real dependencies.
\item When including headers for more special services, it's
      good to add a comment why this header file is needed.
\end{itemize}

\subsection{Distribution packages}

As an example, \emph{ecasound} and \emph{qtecasound} are distributed as separate
packages. This decision has been made because a) they are clearly 
independent, b) they have different external dependencies, and c)
they address different target uses. 

\subsection{Directories}

It's convenient to organize larger sets of source code into separate
directories. For instance in Ecasound, \emph{libecasound} and
\emph{ecatools} are in two separate directories.

\subsection{File groups}

Although files are divided in directories and subdirectories, 
there's still a need to logically group a set of source files based
on their use and role in the overall design. As the use of C++ 
namespaces is very limited in Ecasound (to avoid portability
problems), filename prefixes are used for grouping files. Here's
a short list of commonly used prefixes. 

\begin{description}
\item[audioio*.\{cpp,h\}] 
Audio device and file input/output.
\item[audiofx*.\{cpp,h\}] 
Audio effects and other DSP-related code.
\item[audiogate*.\{cpp,h\}] 
Gate operators.
\item[eca-*.\{cpp,h\}] 
Core functionality.
\item[midi-*.\{cpp,h\}] 
MIDI input/output devices, handlers and controller code.
\item[osc-*.\{cpp,h\}] 
Oscillator and other controller sources.
\item[qe*.\{cpp,h\}] 
Generic prefix for files utilizing both Qt and Ecasound libraries.
\item[samplebuffer-*.\{cpp,h\}] 
Routines and helper functions for processing audio data buffers.
\end{description}

You should note that these are just recommendations - there are no
strict rules on how files should be named.

\subsection{C++ std namespace}
\label{cpp_std_namespace}

The preferred way to access C++ standard library functions is 
to use explicit namespace selectors (``std::string'') in public 
headers files, and \emph{using} declarations in the implementation 
parts (``using std::string''). It's also possible to import the 
whole std namespace (``using namespace std;'') in the beginning
of an implementation file.

% ----------------------------------------------------------------------
\section{Documentation style}

Javadoc-style class documentation is the preferred style.
Class members can be documented either when they are declared (header
files), or when they are defined. Especially when specifying
complicated interfaces, it's better to put documentation in the
definition files. This way the header files remain compact and serve 
better as a reference. 

Here's a few general documentation guide lines:
\begin{description}
\item[Use of 3rd person] 
"Writes samples to memory." instead of "Write samples to memory."
\item[Sentences start with a verb]
"Writes samples to memory." instead of "Samples are written to memory."
\item[This instead of the]
"Get controllers connected to this effect." instead of "Get controllers connected to the effect.
\end{description}

% ----------------------------------------------------------------------
\section{Versioning}

All Ecasound releases have a distinct version number. The
version number syntax is \emph{x.y[.z][-extraT}, where \emph{x} and
\emph{y} are the major and minor numbers, and \emph{z} is an optional
revision number. To test major changes, separate \emph{-preX} or 
\emph{-rcX} versions can be distributed before the actual new 
release.

In addition, all Ecasound libraries have a separate interface 
version. The libtool-style \emph{version:revision:age} versioning
is used. See the libtool documentation for details.

One important thing to note is that the library interface version 
numbers are tied to the source-code level interfaces, not the binary
interfaces. Because binary interfaces are not explicitly versioned,
applications should always statically link against the Ecasound 
libraries. Also, any private source-code interfaces, ie. header
files with a \emph{\_impl.h} postfix, are not part of the versioned
public interface. Applications should not rely on these interfaces!

All changes in the public interfaces are documented in library
specific \emph{ChangeLog} files. These files are usually located in the
top-level source directory of the versioned library.

One thing to note is that Ecasound's versioning practises have 
changed quite a few times during the project's history. The
rules described above only apply to Ecasound 2.2.0 and newer
releases.

% ----------------------------------------------------------------------
% ----------------------------------------------------------------------
\chapter{How Ecasound works?}

% ----------------------------------------------------------------------
\section{Example use cases}

Here's a few common use cases how Ecasound can be used.

\subsection{Simple non-interactive processing}

One input is processed and then written to one output. This includes effect 
processing, normal sample playback, format conversions, etc.

\subsection{Multitrack mixing}

Multiple inputs are mixed into one output.

\subsection{Realtime effect processing}

There's at least one realtime input and one realtime output.
Signal is sampled from the realtime input, processed and
written to the realtime output.

\subsection{One-track recording}

One input is processed and written to one or more outputs.

\subsection{Multitrack recording}

The most common situation is that there are two separate
chains. First one consists of realtime input routed to a
non-realtime output. This is the recording chain. The
other one is the monitor chain and it consists of one or
more non-realtime inputs routed to a realtime output.
You could also route your realtime input to the monitoring
chain, but this is not recommended because of severe
timing problems. To synchronize these two separate chains,
Ecasound uses a special multitrack mode (which should be
enabled automatically).

\subsection{Recycling a signal through external devices}

Just like multirack recording. The only difference is
that realtime input and output are externally
connected.

% ----------------------------------------------------------------------
\section{Audio signal routing}

Basic audio flow inside an Ecasound chainsetup is as follows: Audio 
data is routed from input audio objects to a group of chains. In
the chains audio data is processed using chain operators. After
processing data is routed to output objects.

Using internal loop devices, it's also possible to route signals 
from one chain to another. Looping causes extra latency of one
engine cycle. 

Routing of signals is based on the ability to assign inputs and 
outputs to multiple chains. Assigning an input object to multiple
chains divides the audio signal generating multiple copies of
the original input data. Similarly with an output object, data from
multiple chains is mixed together to one output object.

% ----------------------------------------------------------------------
\section{Control flow}

\subsection{Batch operation}

When Ecasound is run in batch mode, the program flow is simple.
To store the session data, a ECA\_SESSION object is first
created. The created object is then passed as an argument for
ECA\_CONTROL class constructor.

All required configuration of inputs, outputs and chain 
operators is done using the services provided by ECA\_CONTROL.
Once a valid chainsetup is ready for processing, batch 
operation is initiated by issuing ECA\_CONTROL::run(). This
function will block until processing is finished.

\subsection{Interactive operation}

Interactive operation is similar to batch operation. The 
important difference is that processing is started with
ECA\_CONTROL::start(). Unlike run(), start() does not 
block the calling thread. This makes it possible to 
continue using the ECA\_CONTROL interface while engine
is running in the background. 

Two important concepts to understand when 
working with ECA\_CONTROL are the \emph{selected} 
and \emph{connected} chainsetups. ECA\_CONTROL allows 
working with multiple chainsetups, but only one
of them can be edited at a time, and similarly 
only one at a time can be connected to the 
processing engine. For instance if you add a new
input object with add\_audio\_input(), it is 
added to the selected chainsetup. Similarly when
you issue start(), the connected chainsetup is 
started.

% ----------------------------------------------------------------------
% ----------------------------------------------------------------------
\chapter{Library organization}

The primary source for class documentation is header files.
A browsable version of header documentation is at
\texttt{www.wakkanet.fi/\textasciitilde kaiv/ecasound/Documentation/doxygen\_pages.html}
Anyway, let's look at the some central classes.

% ----------------------------------------------------------------------
\section{Interfaces for external use}

The following classes of libecasound are designed as
primary interfaces for external use. The approach 
is based on the Facade (GoF185) design pattern. The primary 
goals are concentrating functionality, and maintaining 
a higher level of interface stability.

\subsection{ECA\_CONTROL - eca-control.h} 

ECA\_CONTROL represents the whole public interface offered by 
libecasound. The primary purpose of ECA\_CONTROL is to offer a 
consistent, straightforward interface for controlling Ecasound. 
The interface is also designed to be more stable than other 
parts of the library.

On important part of ECA\_CONTROL is the functionality for 
interpreting EOS (Ecasound Option Syntax) and EAIM (Ecasound 
Interactive Mode) commands.

\subsection{ECA\_CONTROL\_INTERFACE - eca-control-interface.h}
C++ implementation of the Ecasound Control Interface (ECI) API. See
section ``Ecasound Control Interface'' for more information.

% ----------------------------------------------------------------------
\section{Core classes}

This section introduces the core classes, which define the
central data types and are responsible for the main program
logic.

\subsection{AUDIO\_IO\_PROXY\_SERVER - audioio-proxy-server.h}

Implements a audio input/output subsystem that adds
a second layer of buffering between the main processing 
engine and non-realtime audio input and output objects.

Double buffering is needed to guarantee a realtime constrained 
data stream even when dealing with non-realtime objects like
disk files.

\subsection{CHAIN - eca-chain.h}

Class representing one abstract audio signal chain. CHAIN
objects consist of chain operators, controllers and their
state information.

\subsection{ECA\_CHAINSETUP - eca-chainsetup.h}

ECA\_CHAINSETUP is the central class for storing user-visible 
objects. All inputs, output, chain operator and controller 
objects belonging to one logical setup are attributes of on
ECA\_CHAINSETUP object.

\subsection{ECA\_ENGINE - eca-engine.h} 

ECA\_ENGINE is the actual processing engine. It is initialized with
a pointer to a ECA\_CHAINSETUP object, which has all information 
needed at runtime. In other words ECA\_ENGINE is used to execute
the chainsetup. You could say ECA\_ENGINE renders the final product
according to instruction given in ECA\_CHAINSETUP. 

Processing is started with the exec() member function and
after that, ECA\_ENGINE runs on its own. If 'batch\_mode' 
is selected (parameter to exec()), one started ECA\_ENGINE will 
run until a 'finished' condition is met and then exit 
automatically. Finished means that we have read all available data 
from input sources. Of course if some input has infinite length 
(soundcards for example), processing will never finish. To get 
around this limitation, it's possible to set the processing 
length (see ECA\_CONTROL\_OBJECTS::set\_chainsetup\_processing\_length\_in\_seconds()).

If batch mode is not enabled, engine will just perform
the init phase and starts waiting for further instructions. 
These instructions can be send to the engine using 
the ECA\_ENGINE::command() member function.

ECA\_ENGINE has the following states:
\begin{description}
\item[not\_ready] - ECA\_SESSION object is not ready for processing or
ECA\_ENGINE hasn't been created
\item[running] - processing
\item[stopped] - processing hasn't been started or it has been stopped
before completion
\item[finished] - processing has been completed
\item[error] - an error has occured during prosessing
\end{description}

\subsection{ECA\_SESSION - eca-session.h}

ECA\_SESSION is an abtraction used to represents a group of
chainsetups. At any time, only one chainsetup object at a time
can be active (connected). For modification, one chainsetup
can be set as 'selected'. This means that all configuration
operations are targeted to the selected chainsetup.

The only public access to ECA\_SESSION objects is 
through ECA\_CONTROL objects.

\subsection{MIDI\_SERVER - midi-server.h}

Engine that handles all MIDI input and output.

\subsection{SAMPLEBUFFER - samplebuffer.h}

Basic unit for representing blocks of sample data. The data type used 
to represent single samples, valid value ranges, channel count and system 
endianess are all specified in "samplebuffer.h" and "sample\_specs.h".

% ----------------------------------------------------------------------
\section{Feature and capability interface classes}

Many libecasound classes have similar attribute sets and capabilities. 
To make use of these shared features, most common features have their 
own virtual base classes. All objects that have a particular feature,
inherit the same virtual base class. This makes object grouping
and management easier and less error prone.

\subsection{DYNAMIC\_PARAMETERS<T> - dynamic-parameters.h}

Implemented by all classes that provide a set of generic parameters
of type \emph{T}. Parameter can be observed and modified, and they
usually are identiefied by a unique name and a more verbose 
description. Number of parameters can vary dynamically. Other 
objects can access these parameters without detailed knowledge of 
the object itself.

\subsection{ECA\_AUDIO\_FORMAT - eca-audio-format.h}

Implemented by all classes that have a current audio format that
can be observed and modified.

\subsection{ECA\_AUDIO\_POSITION - eca-audio-position.h}

Implemented by all classes that need to maintain current audio 
position and length.

\subsection{ECA\_SAMPLERATE\_AWARE - eca-samplerate-aware.h}

Implemented by all classes that need knowledge of current
sampling rate.

\subsection{MIDI\_CLIENT - midi-client.h}

Implemented b all classes that require a connection to 
an instance of MIDI\_SERVER.

% ----------------------------------------------------------------------
\section{Object interfaces}

Object interfaces define the behaviour for common objects used
by libecasound. The core classes rarely operate on specific
object types, but instead use object interfaces (abstract 
interfaces). Object interfaces are usually abstract C++ classes 
(instances of these classes cannot be created as some of functions
don't yet have a concreate implementation, ie. they pure virtual
functions).

\subsection{AUDIO\_IO - audioio.h}

Virtual base class for all audio I/O objects. Different types
of audio objects include files, audio devices, sound 
producing program modules, audio server clients, and so on.

More specialized interface classesa are AUDIO\_IO\_DEVICE (for
realtime audio objects) and AUDIO\_IO\_BUFFERED (for POSIX-style
buffered i/o). There's also a special AUDIO\_IO\_MANAGER
interface for managing multiple audio objects of same 
type inside one chainsetup.

\subsection{CHAIN\_OPERATOR - eca-chainop.h}

Virtual base class for chain operators.

\subsection{CONTROLLER\_SOURCE - ctrl-source.h}

Virtual Base class for all controller sources.

\subsection{MIDI\_IO - midiio.h}

Virtual base for objects capable of reading and writing
raw MIDI data.

\subsection{MIDI\_HANDLER - midi-server.h}

Virtual base class for objects capable of receiving 
and processing MIDI data.

% ----------------------------------------------------------------------
\section{Object interface implementations - plugins}

Majority of the classes in libecasound fall to this category. They 
implement the behaviour of some object interface type. As other
parts of the library only use the object interfaces, these
implementation classes are fairly isolated. Changes made inside object 
implementation have no effect to other parts of the library. 
Similarly new object interface implementations can be added without
modifying the core classes.

% ----------------------------------------------------------------------
\section{Utility classes}

\subsection{eca-logger.h - ECA\_LOGGER}

Singleton class that provides an interface to Ecasound's logging 
subsystem. Libecasound sends all log messages to this interface. 
The actual logger implementation can be done in many ways. For example 
in the console mode user-interface of Ecasound, TEXTDEBUG class 
implements the ECA\_LOGGER\_INTERFACE class interface. It sends all 
messages that have a suitable debug level to the console's standard 
output. On the other hand, in qtecasound, ECA\_LOGGER\_INTERFACE is 
implemented using a Qt widget.

New ECA\_LOGGER\_INTERFACE implementations can be registered at
runtime with the \emph{ECA\_LOGGER::attach\_logger()} member
function (declared in eca-logger.h).

% ----------------------------------------------------------------------
\section{Object maps}

Object maps are central repositories for commonly used objects.
Their main purpose is to add flexibility to handling different 
object types - especially to handling dynamic addition and removal
of whole object types. They provide the following services:

\begin{itemize}

\item listing all object types in any of the available 
      categories (for instance, list all effect types)
\item creating new object instances based on keyword strings
      (for instance, returns an mp3 object if ``foo.mp3'' is given
      as keyword)
\item adding new object types (object map item is identified by 
      tuple of ``keyword, regex expression, object type'')
\item removing object types
\item reverse mapping objects back to keyword strings

\end{itemize}

In Ecasound, all access to object maps goes throuh the library-wide
ECA\_OBJECT\_FACTORY class, which provides a set of static functions
to access the object maps.

This system may sound a bit complex, but in practise it is quite
simple and makes a lot of things more easier. For instance, when
adding new object types to the library, you only have to add one
function call which registers the new object; no need to modify any 
other part of the library. It also makes it possible to add new 
types at runtime, including dynamically loaded plugins. 

One special use-case is where an application linked against
libecasound adds its own custom object types on startup. All parts 
of libecasound can use the custom objects, although they are not 
part of library itself.

All objects defined in libecasound are registered in the file
\emph{eca-static-object-maps.cpp}.

\subsection{eca-object.h - ECA\_OBJECT}

A virtual base class that represents an Ecasound object. All objects
handled by the object factory must inherit this class.

\subsection{eca-object-factory.h - ECA\_OBJECT\_FACTORY}

The public interface to Ecasound's object maps. All its functions
are static.

% ----------------------------------------------------------------------
% ----------------------------------------------------------------------
\chapter{Adding new features and components to Ecasound?}

% ----------------------------------------------------------------------
\section{Things to remember when writing new C++ classes}

\subsection{Copy constructor and assignment operator}

Always take a moment to check your copy constructor and the assign 
operation (=operation()). Basicly you have three alternatives: 

\begin{itemize}
\item  Trust the automatically created default definitons. If you don't
have any pointers as data members, this isn't necessarily a bad
choice at all. At least the compiler remembers to copy all members!

\item  If you have pointers to objects as class data members, you should
write definitions for both the copy-constructor and the assign
operation.

\item  If you are lazy, just declare the two functions as null
functions, and put them in \_private\_ access scope. At least this way
nobody will use the functions by accident!
\end{itemize}


% ----------------------------------------------------------------------
\section{Audio objects}

To implement a new audio object type, you must first select which 
top-level class to derive from. Usually this is either AUDIO\_IO
(the top-level class), AUDIO\_IO\_BUFFERED (a more low level interface)
or AUDIO\_IO\_DEVICE (realtime devices).

The second step is to implement the various virtual functions declared
in the parent classes. These functions can be divided into four
categories: 1) attributes (describes the object and its capabilities), 
2) configuration (routines used for setting up the object), 3) main 
functionality (open, close, input, output, etc) and 4) runtime
information (status info).

Adding the new object to Ecasound is much like adding a new effect
(see the next section). Basicly you just add it to the makefiles and
then register it to the appropriate object map (see below).

\subsection{Checklist for Audio Object Implementations}

\begin{enumerate}
\item Check the read\_buffer() and write\_buffer() change the
      internal position with either set\_position\_in\_samples()
      or change\_position\_in\_samples() functions of ECA\_AUDIO\_POSITION.
      Also, when writing a new file, extend\_position() should
      also be called. All this is done automatically if using 
      read\_samples() and write\_samples() from AUDIO\_IO\_BUFFERED.
\item If implementing a proxy object, separately consider all public 
      functions of audioio-proxy.h (whether to reimplement or use
      as they are).
\item Check that open() and close() call AUDIO\_IO::open() and
      AUDIO\_IO::close(), and in the right order.
\item If the object supports seeking, seek\_position() must
      be implemented.
\end{enumerate}

% ----------------------------------------------------------------------
\section{Effects and other chain operators}

Write a new class that inherits from CHAIN\_OPERATOR or any of its
successors. Implement the necessary routines (init, set/get\_parameter, 
process and a default constructor) and add your source files to
libecasound's makefiles. Then all that's left to do is to add your
effect to \emph{libecasound/eca-static-object-maps.cpp},
\emph{register\_default\_objects()}. Now the new effect can be used just 
like any other Ecasound effect (parameters control, effect presets, etc).

Another way to add effects to Ecasound is to write them as LADSPA
plugins. The API is well documented and there's plenty of
example code available. See \texttt{www.ladspa.org} 
for more information.


% ----------------------------------------------------------------------
\section{Differences between audio objects and chain operators}

Design-wise, audio objects and effects (chain operators) aren't that 
far away from each other. Many audio apps don't separate these
concepts at all (for instance most UG based synthesizers). In Ecasound 
though, there are some differences:

Input/output:
\begin{itemize}
\item  audio objects can be opened for reading writing or read\&write
\item  effects are modeless
\item  audio objects read from, or write to a buffer
\item  effects get a buffer which they operate (in-place processing)
\end{itemize}

Audio format:
\begin{itemize}
\item  audio objects have a distinct audio format (sample rate, bits,
     channels)
\item  effects should be capable of accepting audio data in any format
     (this is usually easy as Ecasound converts all input data to its
     internal format)
\end{itemize}

Control:
\begin{itemize}
\item  audio objects can be opened, closed, prepared, started and stopped
\item  effects don't have a running state
\end{itemize}

Position:
\begin{itemize}
\item  audio objects have length and position attributes
\item  effects just process buffers and don't know about their position
\end{itemize}

A good example of the similarity between the two types are LADSPA
oscillator plugins. Although they are effects, you can easily use them 
as audio inputs by specifying:

\begin{verbatim} 

"ecasound -i null -o /dev/dsp -el:sine_fcac,440,1"
 
\end{verbatim} 



% ----------------------------------------------------------------------
\section{LADSPA plugins}

Ecasound supports LADSPA-effect plugins (Linux Audio Developer's Simple
Plugin API). See \texttt{LAD mailing list web site} for 
more info about LADSPA. Other useful sites are 
\texttt{LADSPA home page} and
\texttt{LADSPA documentation}.

% ----------------------------------------------------------------------
% ----------------------------------------------------------------------
\chapter{Application development using the Ecasound framework}

% ----------------------------------------------------------------------
\section{Console mode ecasound - {[}all languages{]}}

This is the easiest way to take advantage of Ecasound features in your
own programs. You can fork ecasound, pipe commands to ecasound's
interactive mode or you can create chainsetup (.ecs) files and load
them to ecasound. You'll be able to do practically anything. The only 
real problem is getting information from ecasound. You'll have to
parse ecasound's ascii output if you want to do this. To make this 
a bit easier, ecasound offers the wellformed output mode 
\ref{Ecasound Interactive Mode - Well-Formed Output Mode} and
dump-* commands. These can be used to easily parse configuration and 
status information.

% ----------------------------------------------------------------------
\section{Ecasound Control Interface - {[}C++, C, Python{]}}

Idea behind Ecasound Control Interface (ECI) is to take a subset of 
functionality provided by libecasound, write a simple API for it, and
port it to various languages. At the moment, at least C++, C and
Python implementations of the ECI API are available and part of the
main Ecasound distribution. ECI is heavily based on the Ecasound
Interactive Mode (EIAM), and the services it provides. 

Specific tasks ECI is aimed at:

\begin{itemize}
\item  1. automating (scripting in its traditional sense)
\item  2. frontends (generic / specialized)
\item  3. sound services to other apps
\end{itemize}

% ----------------------------------------------------------------------
\section{NetECI - {[}various{]}}

NetECI is a network version of the ECI API. When Ecasound is
started in daemon mode (the --daemon option), it creates 
a server for incoming TCP connections. Client applications
can connect to this socket and use the connection to 
control and observe the active session. Multiple clients
can connect to the same session.

The protocol is identical to one used in ECI. Clients 
write EIAM commands to the socket, followed by a CRLF pair.
The server will reply using the well-formed output mode 
syntax (see \ref{Ecasound Interactive Mode - Well-Formed Output Mode}).

See implementation of \emph{ecamonitor} (part of ecatools), 
for a working example.

% ----------------------------------------------------------------------
\section{Libecasound's ECA\_CONTROL class - {[}C++{]}}
 
\large{Note}\normalsize! Direct use of libecasound and libkvutils is
not recommended anymore! Please use the Ecasound Control Interface
(ECI) instead.

By linking your program to libecasound, you can use the ECA\_CONTROL
class for controlling Ecasound. This is a large interface class that
offers routines for controlling all Ecasound features. It's easy
to use while still powerful. Best examples are the utils in ecatools 
directory (most of them are just a couple screenfuls of code). Also, 
qtecasound and ecawave heavily use ECA\_CONTROL. Here's a few lines of 
example code:

\begin{verbatim} 

--cut--
ECA_SESSION esession;
ECA_CONTROL ctrl (&esession);
ctrl.new_chainsetup("default");
[... other setup routines ]
ctrl.start(); // starts processing in another thread (doesn't block)
--cut--
 
\end{verbatim} 


If you don't want to use threads, you can run the setup in
batch mode:

\begin{verbatim} 

--cut--
ECA_SESSION esession;
ECA_CONTROL ctrl (&esession);
ctrl.add_chainsetup("default");
[... other setup routines ]
ctrl.run(); // blocks until processing is finished
--cut--
 
\end{verbatim} 


% ----------------------------------------------------------------------
\section{Ecasound classes as building blocks - {[}C++{]}}

\large{Note}\normalsize! Direct use of libecasound and libkvutils is
not recommended anymore! Please use the Ecasound Control Interface
(ECI) instead.
 
You can also use individual Ecasound classes directly.
This means more control, but it also means more work. Here's
another short sample:

\begin{verbatim} 
--cut--
- create a SAMPLE_BUFFER object for storing the samples
- read samples with an audio I/O object - for example WAVEFILE
- process sample data with some effect class - for example EFFECT_LOWPASS
- maybe change the filter frequency with EFFECT_LOWPASS::set_parameter(1, new_value)
- write samples with an audio I/O object - OSSDEVICE, WAVEFILE, etc.
--cut--
 \end{verbatim}

% ----------------------------------------------------------------------
% ----------------------------------------------------------------------
\chapter{Protocols and Interfaces}

% ----------------------------------------------------------------------
\section{Ecasound Interactive Mode - Well-Formed Output Mode}
\label{Ecasound Interactive Mode - Well-Formed Output Mode}

By issuing the EIAM command ``int-output-mode-wellformed'', 
Ecasound will start printing all messages using the following
format:

% FIXME: write this using rfc-style ABNF (see RFC2234)
\begin{verbatim}
<message> = <loglevel><sp><msgsize>(<genmsg> | <returnmsg>)

<loglevel> = <integer>      ; loglevel number
<msgsize = <integer>        ; size of content in octets
<genmsg> = <contentblock>   ; generic log message
<returnmsg> = <sp><returntype><contentblock>
                            ; EIAM return value message
<contentblock> = <crlf><content><crlf><crlf>
                            ; actual content of the message
<returntype> = ``i'' | ``li'' | ``f'' | ``s'' | ``S'' | ``e''
                            ; type of the return value (see ECI/EIAM docs)
<content> = *<octet>        ; zero or more octets of message content

<sp> = 0x20                 ; space
<octet> = 0x00-0xff         ; 8bits of data
<crlf> = <cr><lf>           ; new line 
<cr> = 0x0d                 ; carriage return
<lf> = 0x0a                 ; line feed
<integer> = +<digit>        ; one or more digits
<digit> = 0x30-0x39         ; digits 0-9
\end{verbatim}

% ----------------------------------------------------------------------
% ----------------------------------------------------------------------
\chapter{References}

\begin{thebibliography}{10}
 \bibitem[ISO14822]{c++std} 
   ISO/IEC 14882 - Programming language C++

 \bibitem[Lakos96]{Lakos96} 
   Lakos, John: Large-Scale C++ Software Design, Addison Wesley, 1996

 \bibitem[Larman01]{Larman01} 
   Larman, Craig: Applying UML and Patterns, 2nd ed., Prentice Hall, 2001

 \bibitem[Stroustrup97]{Stroustrup97} 
   Stroustrup, Bjarne: C++ Programming Language, 3rd edition, Addison Wesley, 1997

    % - Modern C++ Design 
    % - Design Patterns and Contracts [xxx]
    % - http://www.bell-labs.com/~cope/Patterns/C++Report/IdiomGeometry/IdiomGeometry-1.html
    % - esimerkkejä fyysisen organisaation suunnittelusta
    % - http://wwwhome.cs.utwente.nl/~tcm/developersguide/developersguidenode4.html
    % - http://users.vnet.net/wwake/pubs/1997/software-guide/coding.shtml
\end{thebibliography}

\end{document}
